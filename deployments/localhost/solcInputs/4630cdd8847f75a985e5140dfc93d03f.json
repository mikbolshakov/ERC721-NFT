{
  "language": "Solidity",
  "sources": {
    "contracts/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n// реализация интерфейса IERC165\ncontract ERC165 is IERC165 {\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "contracts/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Metadata.sol\";\nimport \"./Strings.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./ERC165.sol\";\n\n// реализация интерфейса ERC721 (по стандарту) + дополнительная логика\ncontract ERC721 is ERC165, IERC721, IERC721Metadata {\n    using Strings for uint;\n    string private _name;\n    string private _symbol;\n\n    mapping(address => uint) private _balances; // адрес => количество нфт, которыми он владеет\n    mapping(uint => address) private _owners; // айди токена => адрес-владелец токена\n    mapping(uint => address) private _tokenApprovals; // айди токена => адресс, который может этим токеном распоряжаться\n    mapping(address => mapping(address => bool)) private _operatorApprovals; // адрес владельца нфт => адрес оператора => может/не может оператор распоряжаться токенами владельца\n\n    modifier _requireMinted(uint tokenId) {\n        require(_exists(tokenId), \"not minted!\");\n        _;\n    }\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    // базовая ссылка, к которой будем приставлять результат функции tokenURI\n    function _baseURI() internal pure virtual returns (string memory) {\n        return \"\"; // https://erc721/...\n    }\n\n    // создаем полноценную ссылку на изображение\n    function tokenURI(uint tokenId) public view virtual _requireMinted(tokenId) returns (string memory) {\n        string memory baseURI = _baseURI();\n        return\n            bytes(baseURI).length > 0 // если есть базовая ссылка, тогда склеиваем результаты\n                ? string(abi.encodePacked(baseURI, tokenId.toString()))\n                : \"\";\n    }\n\n    function balanceOf(address owner) public view returns (uint) {\n        require(owner != address(0), \"owner cannot be zero\");\n        return _balances[owner];\n    }\n\n    function ownerOf(uint tokenId) public view _requireMinted(tokenId) returns (address) {\n        return _owners[tokenId];\n    }\n\n    // проверка, что токен существует (что у него есть владелец)\n    function _exists(uint tokenId) internal view returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    function approve(address to, uint tokenId) public {\n        address _owner = ownerOf(tokenId);\n        require(_owner == msg.sender || isApprovedForAll(_owner, msg.sender),\"not an owner!\");\n        require(to != _owner, \"can't approve to self\");\n        _tokenApprovals[tokenId] = to;\n        emit Approval(_owner, to, tokenId);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public {\n        require(msg.sender != operator, \"can't approve to self\");\n        _operatorApprovals[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    // проверка approve - управляет конкретным токеном\n    function getApproved(uint tokenId) public view _requireMinted(tokenId) returns(address) {\n        return _tokenApprovals[tokenId];\n    }\n\n    // проверка setApprovalForAll - управляет всеми токенами\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    function transferFrom(address from, address to, uint tokenId) external {\n        require(_isApprovedOrOwner(msg.sender, tokenId),\"not approved or owner\");\n        _transfer(from, to, tokenId);\n    }\n\n    // безопасная отправка нфт\n    function safeTransferFrom(address from, address to, uint tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    // безопасная отправка нфт с данными\n    function safeTransferFrom(address from, address to, uint tokenId, bytes memory data) public {\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"not an owner!\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    // безопасная - тот, кто получает нфт, может их принять\n    function _safeTransfer(address from, address to, uint tokenId, bytes memory data) internal {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"transfer to non-erc721 receiver\");\n    }\n\n    // переписываем в нашей базе факт владения, что данным айди владеет новый адрес\n    function _transfer(address from, address to, uint tokenId) internal {\n        require(ownerOf(tokenId) == from, \"incorrect owner!\");\n        require(to != address(0), \"to address is zero!\");\n        _beforeTokenTransfer(from, to, tokenId);\n        delete _tokenApprovals[tokenId];\n        _balances[from]--;\n        _balances[to]++;\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    // проверка, является ли получатель ск и может ли этот ск принимать нфт\n    function _checkOnERC721Received(address from, address to, uint tokenId, bytes memory data) private returns (bool) {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data) returns (bytes4 retval) { // если возвращает retval, то этот ск может принять нфт\n                return retval == IERC721Receiver.onERC721Received.selector; // принимающий ск должен иметь функцию onERC721Received\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"Transfer to non-erc721 receiver\"); // стандартное сообщение: либо функция onERC721Received пустая, либо ее нет\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason)) // откатываем транзакцию с сообщением, которое хранится в reason (reason прописана в onERC721Received)\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    function _isApprovedOrOwner(address spender, uint tokenId) internal view returns (bool) {\n        address owner = ownerOf(tokenId);\n        return (spender == owner ||\n            isApprovedForAll(owner, spender) ||\n            getApproved(tokenId) == spender);\n    }\n\n    // обе функции пустые, так как никаких действий до или после перевода мы не делаем\n    function _beforeTokenTransfer(address from, address to, uint tokenId) internal virtual {}\n\n    function _afterTokenTransfer(address from, address to, uint tokenId) internal virtual {}\n\n    // по функциям выше мы реализовали интерфейс IERC721\n    // ниже функции, которые вводят и выводят нфт из оборота (не являются частью стандарта)\n\n    // минтим\n    function _safeMint(address to, uint tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    // минтим с данными\n    function _safeMint(address to, uint tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, data), \"non-erc721 receiver\");\n    }\n\n    function _mint(address to, uint tokenId) internal virtual {\n        require(to != address(0), \"zero address to\");\n        require(!_exists(tokenId), \"this token id is already minted\");\n        _beforeTokenTransfer(address(0), to, tokenId);\n        _owners[tokenId] = to;\n        _balances[to]++;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    function burn(uint tokenId) public virtual {\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"not owner!\");\n        _burn(tokenId);\n    }\n\n    function _burn(uint tokenId) internal virtual {\n        address owner = ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId);\n        delete _tokenApprovals[tokenId];\n        _balances[owner]--;\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    // функция, которая показывает, что мы поддерживаем два наших интерфейса\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n// расширение (абстрактный контракт) для поиска токенов по индексу в целом и по индексу на счету конкретного адреса\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    uint[] private _allTokens; // все айди нфт\n    mapping(address => mapping(uint => uint)) private _ownedTokens; // владелец нфт => индекс нфт в массиве => айди этого нфт\n    mapping(uint => uint) private _allTokensIndex; // айди токена в массиве _allTokens => индекс этого нфт\n    mapping(uint => uint) private _ownedTokensIndex; // айди токена у указанного адреса => индекс этого нфт\n\n    function totalSupply() public view returns (uint) {\n        return _allTokens.length;\n    }\n\n    function tokenByIndex(uint index) public view returns (uint) {\n        require(index < totalSupply(), \"out of bonds\");\n        return _allTokens[index];\n    }\n\n    function tokenOfOwnerByIndex(address owner, uint index) public view returns(uint) {\n        require(index < balanceOf(owner), \"out of bonds\");\n        return _ownedTokens[owner][index];\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint tokenId) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if(from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if(from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n\n        if(to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if(to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    // ниже 4 функции по добавлению и удалению токенов в мэппингах с индексами\n    function _addTokenToAllTokensEnumeration(uint tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    function _removeTokenFromAllTokensEnumeration(uint tokenId) private {\n        uint lastTokenIndex = _allTokens.length - 1;\n        uint tokenIndex = _allTokensIndex[tokenId];\n        uint lastTokenId = _allTokens[lastTokenIndex];\n        _allTokens[tokenIndex] = lastTokenId; // ставим последний элемент массива на место необходимого индекса\n        _allTokensIndex[lastTokenId] = tokenIndex; // присваиваем этому элементу новый индекс\n        delete _allTokensIndex[tokenId]; // удаляем информацию об айди последнего элемента\n        _allTokens.pop(); // удаляем последний элемент\n    }\n\n    function _addTokenToOwnerEnumeration(address to, uint tokenId) private {\n        uint _length = balanceOf(to); // количество токенов у адреса\n        _ownedTokensIndex[tokenId] = _length; // добавляем токен на индекс _length\n        _ownedTokens[to][_length] = tokenId; // добавляем в мэппинг: у этого адреса на таком-то индексе есть такой-то токен\n    }\n\n    function _removeTokenFromOwnerEnumeration(address from, uint tokenId) private {\n        uint lastTokenIndex = balanceOf(from) - 1;\n        uint tokenIndex = _ownedTokensIndex[tokenId]; // какой токен удаляем\n        if (tokenIndex != lastTokenIndex) {\n            uint lastTokenId = _ownedTokens[from][lastTokenIndex];\n            _ownedTokens[from][tokenIndex] = lastTokenId;\n            _ownedTokensIndex[lastTokenId] = tokenIndex;\n        }\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    // поддерживает интерфейс IERC721Enumerable\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721) returns(bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/ERC721URIStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ERC721.sol\";\n\n// дополнение к NToken'у для того, чтобы состыковать id нфт и ссылку в ipfs\nabstract contract ERC721URIStorage is ERC721 {\n    mapping(uint => string) private _tokenURIs; // айди токена => ссылка в ipfs\n\n    function _setTokenURI(uint tokenId, string memory _tokenURI) internal virtual _requireMinted(tokenId) {\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    // делаем полноценную ссылку на картинку склеивая базу и токенURI\n    function tokenURI(uint tokenId) public view virtual override _requireMinted(tokenId) returns (string memory) {\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n        return super.tokenURI(tokenId); // если база есть, а токенURI нету\n    }\n\n    // также переопределяем burn - чистим наш мэппинг\n    function _burn(uint tokenId) internal virtual override {\n        super._burn(tokenId);\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n"
    },
    "contracts/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// интерфейс, чтобы проверить, реализует ли наш контракт ERC721 другие интерфейсы\ninterface IERC165 {\n  function supportsInterface(bytes4 interfaceId) external view returns(bool);\n}"
    },
    "contracts/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC721 {\n  event Transfer(address indexed from, address indexed to, uint indexed tokenId);\n  event Approval(address indexed owner, address indexed approved, uint indexed tokenId);\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n  function balanceOf(address owner) external view returns (uint);\n  \n  function ownerOf(uint tokenId) external view returns (address);\n\n  function safeTransferFrom(address from, address to, uint tokenId, bytes calldata data) external;\n\n  function safeTransferFrom(address from, address to, uint tokenId) external;\n\n  function transferFrom(address from, address to, uint tokenId) external;\n\n  function approve(address to, uint tokenId) external;\n\n  function setApprovalForAll(address operator, bool approved) external;\n\n  function getApproved(uint tokenId) external view returns (address);\n\n  function isApprovedForAll(address owner, address operator) external view returns (bool);\n}"
    },
    "contracts/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ERC721.sol\";\n\n// интерфейс для расширения ERC721Enumerable (поиск токенов по индексу)\ninterface IERC721Enumerable is IERC721 {\n  function totalSupply() external view returns(uint);\n\n  function tokenOfOwnerByIndex(address owner, uint index) external view returns(uint);\n\n  function tokenByIndex(uint index) external view returns(uint);\n}"
    },
    "contracts/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\n\n// дополнение к IERC721\ninterface IERC721Metadata is IERC721 {\n  function name() external view returns(string memory);\n\n  function symbol() external view returns(string memory);\n  \n  function tokenURI(uint tokenId) external view returns(string memory);\n}"
    },
    "contracts/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// интерфейс, который нужен в ск, чтобы тот мог принимать нфт\n// в таком ск должна быть функция onERC721Received, которая возвращает собственный селектор\ninterface IERC721Receiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/NToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ERC721.sol\";\nimport \"./ERC721URIStorage.sol\";\nimport \"./ERC721Enumerable.sol\";\n\n// контракт с nft\ncontract NToken is ERC721, ERC721Enumerable, ERC721URIStorage {\n    address public owner;\n    uint currentTokenId; // числовой айди для минта и переводов\n\n    constructor() ERC721(\"NToken\", \"NTK\") {\n        owner = msg.sender;\n    }\n\n    function _baseURI() internal pure override returns (string memory) {\n        return \"ipfs://\";\n    }\n\n    // минтим и сопоставляем id токена с ссылкой в ipfs (через интерфейс ERC721URIStorage)\n    function safeMint(address to, string calldata tokenId) public {\n        require(owner == msg.sender, \"not an owner!\");\n        _safeMint(to, currentTokenId);\n        _setTokenURI(currentTokenId, tokenId); // tokenId - ссылка в ipfs (ipfs://adc242)\n        currentTokenId++;\n    }\n\n    //переопределяем нижние 4 функции в двух случаях (ERC721, ERC721URIStorage), \n    // в остальных случаях поднимаемся по иерархии выше\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, ERC721Enumerable) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    } \n\n    function _burn(uint tokenId) internal override(ERC721, ERC721URIStorage) {\n        super._burn(tokenId);\n    }\n\n    function tokenURI(uint tokenId) public view override(ERC721, ERC721URIStorage) returns (string memory) {\n        return super.tokenURI(tokenId);\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint tokenId) internal override(ERC721, ERC721Enumerable) {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n}\n"
    },
    "contracts/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// конвертация чисел в строку\nlibrary Strings {\n  function toString(uint256 value) internal pure returns(string memory) {\n    if (value == 0) {\n      return \"0\";\n    }\n    uint256 temp = value;\n    uint256 digits;\n    while (temp != 0) {\n      digits++;\n      temp /= 10;\n    }\n    bytes memory buffer = new bytes(digits);\n    while (value != 0) {\n      digits -= 1;\n      buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n      value /= 10;\n    }\n    return string(buffer);\n  }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}